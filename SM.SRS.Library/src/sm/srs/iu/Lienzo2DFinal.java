/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package sm.srs.iu;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Cursor;
import static java.awt.Cursor.DEFAULT_CURSOR;
import static java.awt.Cursor.HAND_CURSOR;
import static java.awt.Cursor.MOVE_CURSOR;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Shape;
import java.awt.Stroke;
import java.awt.geom.Point2D;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;
import sm.srs.eventos.LienzoEvent;
import sm.srs.eventos.LienzoListener;
import sm.srs.graficos.myEllipse;
import sm.srs.graficos.myLine;
import sm.srs.graficos.myRectangle;
import sm.srs.graficos.myShape;

/**
 *Clase lienzo
 * @author Sergi Ruiz Sánchez
 */
public class Lienzo2DFinal extends javax.swing.JPanel {
    //Atributos
    /**
     * Lista con los manejadores
     */
    ArrayList<LienzoListener> lienzoEventListeners = new ArrayList(); 
    /**
     * Imagen de fondo
     */
    private BufferedImage img = null; 
    /**
     * Puntos usados para saber el origen de la figura y luego poder moverla, operar con ella, etc
     */
    private Point origin, movile;   
    /**
     * Figuras rellenas o relieves
     */
    private boolean isFilled = false; 
    /**
     *Tipo de figura; NULL = No tiene tipo, por lo que no pinta nada en pantalla al interactuar con ella
     */
    private figure currentFigure = figure.NULL;
    /**
     * Tipos de figuras
     */
    public enum figure{ 
        OVAL, LINE, RECTANGLE, NULL
    }
    
    /**
     * Para saber si en ese momento hay una figura seleccionada o no
     */
    private boolean shapeSelected = false; 
    /**
     * Array de formas
     */
    private List<myShape> vShape = new ArrayList();  
    /**
     * Objeto de la clase myLine
     */
    private myLine l;   
    /**
     * Objeto de la clase myRectangle
     */
    private myRectangle r; 
    /**
     * Objeto de la clase myEllipse
     */
    private myEllipse e;    
    /**
     * Punto usados para poder manejar las líneas
     */
    Point2D p1 = new Point2D.Double(); 
    /**
     * Punto usados para poder manejar las líneas
     */
    Point2D p2 = new Point2D.Double();

    private boolean edit = false;   //Si estamos o no editando una figura
    
    myRectangle boundingBox = null;    //Rectángulo que nos va a servir de boundingbox
    Stroke border = new BasicStroke();  //Borde de la figura

    
    //Variables que aplicaremos al objeto seleccionado
    private myShape moveShape;  //Es la figura que tenemos seleccionada
    private float transparency = 1.0F;  //Grado de transparencia entre 0.0F y 1.0F
    private boolean smooth = false; //Si estamos aplicando un suavizado de las formas o no
    private Color borderColor = Color.BLACK;    //Color del borde
    private Color fillColor = Color.BLACK; //Color del relleno
    private float thickness = 1.0F; //Grosor de los bordes 
    private String gradient = null; //String que nos indica si tenemos gradiente o no (horizontal, vertical, null)
    private String pattern = "Línea continua"; //Patrón de las líneas

    
    /**
     * Constructor por defecto
     */
    public Lienzo2DFinal() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        form = new javax.swing.JPanel();

        setLayout(new java.awt.BorderLayout());

        form.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                formMouseDragged(evt);
            }
            public void mouseMoved(java.awt.event.MouseEvent evt) {
                formMouseMoved(evt);
            }
        });
        form.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseExited(java.awt.event.MouseEvent evt) {
                formMouseExited(evt);
            }
            public void mousePressed(java.awt.event.MouseEvent evt) {
                formMousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                formMouseReleased(evt);
            }
        });

        javax.swing.GroupLayout formLayout = new javax.swing.GroupLayout(form);
        form.setLayout(formLayout);
        formLayout.setHorizontalGroup(
            formLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        formLayout.setVerticalGroup(
            formLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );

        add(form, java.awt.BorderLayout.CENTER);
    }// </editor-fold>//GEN-END:initComponents

    
    private void formMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseDragged
        movile = evt.getPoint();
        
        //Si tenemos figuras y ya tenemos seleccionada una figura
        if(edit && vShape.isEmpty() == false && moveShape != null){
            currentFigure = Lienzo2DFinal.figure.NULL;
            this.setCursor(new Cursor(MOVE_CURSOR));
            this.moveFigure(moveShape,movile);  //Método para mover la figura seleccionada
        }
        
        //No tenemos seleccionada ninguna figura (si hacemos dragged es porque estamos creando 
        //una y estamos estableciendo su tamaño)
        else{
            this.setCursor(new Cursor(HAND_CURSOR));
            this.setSizeFigure(evt);
        }
        
        this.repaint();
    }//GEN-LAST:event_formMouseDragged

    private void formMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMousePressed
         origin = evt.getPoint();
        
        //Hemos pulsado en editar
        if(edit && vShape.isEmpty() == false){
            currentFigure = Lienzo2DFinal.figure.NULL;
            this.getSelectedShape(origin);  //Al ir a editar, ver sobre que figura hemos hecho pressed
            isLine(moveShape,origin);  //Método para ver si es línea y calcular la distancia de los puntos solo una vez,
                                       //ya que si lo hacemos en el Dragged se comporta extraño el movimiento
        }
        
        //No estamos editando una figura (un pressed significa que estamos estableciendo el 
        //punto origen de una nueva figura)
        else{
            if(currentFigure != Lienzo2DFinal.figure.NULL){
                this.createFigure(origin);

            }
        }
    }//GEN-LAST:event_formMousePressed

    private void formMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseReleased
       this.setCursor(new Cursor(DEFAULT_CURSOR));
    }//GEN-LAST:event_formMouseReleased

    private void formMouseMoved(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseMoved
        int rgb []= {-1,-1,-1};
                        
        //Obtenemos el tipo de la imagen
        int type = this.img.getType();
        
        //Si la imagen está en RGB
        if(type == 5){
            img.getRaster().getPixel(evt.getX(), evt.getY(), rgb);
        }
               
        this.notifysetCoordinatesEvent(new LienzoEvent(this,evt.getPoint(), rgb));

    }//GEN-LAST:event_formMouseMoved

    private void formMouseExited(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseExited
        this.notifyOutsideEvent(new LienzoEvent(this,true));
    }//GEN-LAST:event_formMouseExited
                                

    /**
     * Método con el que pintaremos todas las figuras dentro del vector
     * en el lienzo; Para ello, creamos un objeto Graphics2D y llamamos
     * para cada figura al mñetodo paint asociado.
     * @param g objeto de la clase Graphics para pintar lo necesario
     */
    
    @Override
    public void paint(Graphics g){
       super.paint(g);
       Graphics2D g2d = (Graphics2D) g;
       
       if(img!=null){
           g2d.drawImage(img,0,0,this);
           g2d.clipRect(0, 0, img.getWidth(), img.getHeight());
       }
       
       if(!vShape.isEmpty()){
           for(myShape s:vShape){
               s.pintar(g2d);
           }
       }
       
    }



    
//-------------------------SETTERS----------------------------------//
    
    /**
     * Método para cambiar el color del borde de la figura; Podemos ver
     * como se cambia el parámetro en la clase, pero si además hay un
     * objeto seleccionado, también se lo cambia a él directamente.
     * @param currentColor nuevo color de borde
     */
    public void setColor(Color currentColor) {
        
        if(this.moveShape != null & this.shapeSelected == true){
            this.moveShape.setColor(currentColor);
            

            
        }
        
        this.borderColor = currentColor;
        this.repaint(); 
        

    }
    
    /**
     * Color para rellenar (Solo en el caso de que realmente vayamos a rellenar)
     * @param currentColor nuevo color de relleno
     */
    public void setRefillColor( Color currentColor){
        
        if(this.moveShape != null & this.shapeSelected == true){
            this.moveShape.setFillColor(currentColor);
        }
        
        this.fillColor = currentColor;
        this.repaint(); 
        
        
    }
    
    /**
     * Método para cambiar el enumerado que nos indica el tipo de figura
     * que estamos dibujando en ese momento
     * @param currentFigure tipo de figura dibujándose en ese momento
     */
    public void setCurrentFigure(Lienzo2DFinal.figure currentFigure) {
        this.currentFigure = currentFigure;
    }
    
    /**
     * Método para cambiar el nivel de transparencia
     * @param transparency valor entre 0.0F y 1.0F si proviene del 
     * slider, y nos dice el nuevo valor de la transparencia. Si vale
     * 2.0F, sabremos que el botón de transparencia ha pasado a estar 
     * selected = false, por lo que transparencia valdrá 1.0F; Si recoge valor 3.0F,
     * es porque está a selected = true, por lo que pasará a valer 0.5F
     */
    public void setTransparency(float transparency) {
        
        this.transparency = transparency;
        
        if(this.moveShape != null & this.shapeSelected == true){  
            this.moveShape.setTransparency(transparency);
        }
        
        this.repaint();

    }
    
    /**
     * Método para cambiar el grosor del borde, creando una nueva línea de 
     * dicho grosor.
     * @param thickness nos indica el nuevo grosor
     */
    public void setThickness(int thickness) {
        this.thickness = thickness;
        border = new BasicStroke(thickness);

        if(this.moveShape != null & this.shapeSelected == true){
            this.moveShape.setThickness(thickness);
            this.moveShape.setStroke(border);
        }
        
        this.repaint();


    }
    
    /**
     * Método para indicar si la figura tiene o no los bordes suavizados
     * @param smooth indica si hay que suavizar los bordes
     */
    public void setSmooth(boolean smooth) {
        
        this.smooth = smooth;

        if(this.moveShape !=null){
            this.moveShape.setRender(smooth);
        }
        
        this.repaint();

        
    }
    
    /**
     * Métodos que recogerá un String (horizontal, vertical o null), y determinará
     * a partir de él el tipo de gradiente a realizar.
     * 
     * @param type String con el tipo de gradiente
     */
    public void setGradient (String type){

            if(type != "null"){
                this.gradient = type;
                if(this.moveShape != null & this.shapeSelected == true){
                    this.moveShape.setGradient(type);
                }
            }
            
            else{
                this.gradient = null;
                if(this.moveShape != null & this.shapeSelected == true){
                    this.moveShape.setGradient("null");
                }
            }
            
            this.repaint();
    }
    
    /**
     * Método para indicar si pasamos o no a estar en modo edición
     * @param edit si estamos o no editando
     */
    public void setEdit(boolean edit) {
        this.edit = edit;
    }
    
    /**
     * Método para indicar el tipo de patrón (Línea continua, línea punteada,
     * null), y aplicarlo.
     * @param pattern String con el tipo de patrón a aplicar
     */
    public void setPattern(String pattern){
        this.pattern = pattern;
        
        if(this.moveShape != null & this.shapeSelected == true){
            this.moveShape.setPattern(pattern);
        }
        
        this.repaint();
    }
    
    /**
     * Método para que cuando vayamos a crear una imagen nueva no se modifiquen los 
     * parámetros de la figura que está actualmente en moveShape
     * @param selected booleano que nos indicará si, en el caso de tener una figura en moveShape, 
     * aplicarle o no los cambios que hagamos en la ventana principal de color, transparencia...
     */
    
    public void setShapeSelected(boolean selected){
       this.shapeSelected = selected; 
       
       if(selected == false){
           this.moveShape = null;
       }
    }
    
    /**
     * Método para cambiar el atributo de relleno
     * @param filled relleno o no
     */
    public void setIsFilled(boolean filled){
        
        if(this.moveShape != null){
            this.moveShape.setRefilled(filled);
        }
        
        this.repaint();
    }
    
    
    /**
     * Método para asociar una imágen al lienzo; La obtenemos del parámetro de entrada, y recorremos
     * todos los pixeles; En el momento en el que haya uno que no sea blanco, significa que no se trata
     * de un nuevo lienzo; Si lo fuese, le creamos un borde de un pixel de color azul
     * @param img imagen a asociar
     */
    public void setImg(BufferedImage img){
 
        this.img = img;
        boolean newImage = true;
        
        if(img!=null) {
            setPreferredSize(new Dimension(img.getWidth(),img.getHeight()));
        
                    
            Graphics2D graphics = this.img.createGraphics();


            for(int i = 0; i < img.getWidth(); i++){        //Si encontramos en la imagen algún pixel que no sea negro, es porque no está recien creada
                for(int j = 0; j < img.getHeight(); j++){
                    if(img.getRGB(i, j) != 0){
                        newImage = false;
                        break;
                    }
                }

                if(newImage == false){
                    break;
                }
            }


            if(this.img.getType() == BufferedImage.TYPE_INT_ARGB && newImage){

                graphics.setPaint (Color.BLUE);
                graphics.fillRect ( 0, 0, this.img.getWidth(), this.img.getHeight());
                graphics.setPaint (Color.WHITE);
                graphics.fillRect ( 1, 1, this.img.getWidth()-2, this.img.getHeight()-2);
            }   
        }
        
       this.repaint();
        
    }
    
    /**
     * Creamos una nueva imagen con las dimensiones dadas; Del mismo modo que hemos
     * hecho antes, le asignamos un borde azul de 1 pixel
     * @param width ancho de la nueva iamgen
     * @param height alto de la nueva imagen
     */
    
    public void setImgSize(int width, int height){
        BufferedImage newImg = new BufferedImage(width,height,BufferedImage.TYPE_INT_ARGB);
        this.img = newImg;
        
        Graphics2D graphics = this.img.createGraphics();
        
        
        
        if(img.getType() == BufferedImage.TYPE_INT_ARGB){
            graphics.setPaint (Color.BLUE);
            graphics.fillRect ( 0, 0, this.img.getWidth(), this.img.getHeight());
            graphics.setPaint (Color.WHITE);
            graphics.fillRect ( 1, 1, this.img.getWidth()-2, this.img.getHeight()-2);
            this.repaint();
        } 
    }
    
    /**
     * Método para establecer el tamaño de la figura mientras hacemos dragged
     * @param evt se corresponde con el evento de ratón, obtendremos de él las
     * coordenadas de este
     */
    private void setSizeFigure(java.awt.event.MouseEvent evt){
        switch(currentFigure){
            case LINE:
               l.setShape(l.getP1(),evt.getPoint());
               break;
                
            case OVAL:
              e.setShape(origin, evt.getPoint());
              break;
              
            case RECTANGLE:              
              r.setShape(origin, evt.getPoint());
              break;
              
            default:
                break;
       }
        
       this.repaint();
    }
    
    /**
     *  Método para que al crear una figura tenga los valores de los parámetros actuales de color,líneas y relleno
     * @param shape figura actual
     */
    private void setParameters(myShape shape){  
        shape.setColor(borderColor);
        shape.setRefilled(isFilled);
        
        if(this.isFilled == true){
            shape.setFillColor(fillColor);
        }
        
        shape.setPattern(pattern);
        shape.setRender(smooth); /*Alisado*/
        shape.setThickness(thickness);
        shape.setGradient(gradient);

    }

    
//------------------GETTERS----------------------------------------//
    
    /**
     * Método para saber si una figura tiene o no relleno
     * @return boolean Devuelve si está o no rellena
     */
    public boolean isFilled() {
        return isFilled;
    }

    /**
     * Método para ver si estamos o no en modo edición
     * @return boolean Devuelve si estamos en modo edición
     */
    public boolean isEdit() {
        return edit;
    }

    /**
     * Método que nos indica el nivel de transparencia
     * @return float Nivel de transparencia
     */
    public float isTransparency() {
        return transparency;
    }

    /**
     * Método que nos dice si estamos suavizando bordes o no
     * @return boolean Estamos o no suavizando bordes
     */
    public boolean isSmooth() {
        return smooth;
    }
    
    /**
     * Método que nos indica el grosor del borde del objeto
     * @return float Valor del grosor
     */
    public float getThickness() {
        return thickness;
    }
    
    /**
     * Método que nos indica si tenemos actualmente una figura seleccionada
     * @return boolean Tenemos o no una figura seleccionada
     */
    public boolean getShapeSelected(){
        return this.shapeSelected;
    }
    
    /**
     * Método para indicarnos el tipo de gradiente actual
     * @return String Nos dice el tipo de gradiente (horizontal, vertical, null)
     */
    public String getGradient(){
        return this.gradient;
    }
    
    /**
     * Método para indicar el tipo de patrón usado
     * @return String Tipo de patrón (Línea continua, línea punteada, null)
     */
    public String getPattern(){
        return this.pattern;
    }
    
    /**
     * Método para mostrar devolver una imágen
     * @param drawVector nos indica si pasamos la imágen añadiendole
     * o no el vector de formas
     * @return BufferedImage imagen que se ha pedido
     */
    public BufferedImage getImg(boolean drawVector){

        
        if(drawVector){
          BufferedImage imgout; 
          
          if(img.getType() == 0){   /*Imagen de la webcam*/
            imgout = new BufferedImage(img.getWidth(),img.getHeight(),BufferedImage.TYPE_INT_ARGB);
          }
          
          else{
            imgout = new BufferedImage(img.getWidth(),img.getHeight(),img.getType());
          }
          
          
          this.paint(imgout.createGraphics());
          
          return imgout;
          
        }
        
        else{
            return img;
        }
        
    }
    
    /**
     * Método para devolver el color del borde
     * @return Color color del borde
     */
    public Color getColor(){
        return this.borderColor;
    }
    
    /**
     * Método para devolver el color del relleno
     * @return Color color del relleno
     */
    public Color getFillColor(){
        return this.fillColor;
    }

    /**
     * Método para devolver qué figura estamos pintando actualmente
     * @return figure tipo de figura siendo pintada actualmente
     */
    public figure getCurrentFigure(){
        return this.currentFigure;
    }
    
    /**
     * Método para devolver la figura seleccionada
     * @return myShape figura seleccionada
     */
    public myShape getMoveShape(){
        return this.moveShape;
    }

 
    /**
     * Método para buscar dentro del array de figuras sobre cual hemos hecho pressed
     * @param p punto sobre el cual hemos realizado el pressed
     */
    private void getSelectedShape(Point2D p){
        
        
        for(int i = vShape.size()-1; i >=0; i--){
            if(vShape.get(i).contains(p)){
                this.moveShape = vShape.get(i);
                this.shapeSelected = true;
                

                this.borderColor = this.moveShape.getColor();
                this.isFilled = this.moveShape.getRefilled();
                this.fillColor = this.moveShape.getFillColor();
                this.transparency = this.moveShape.getTransparency();
                this.thickness = this.moveShape.getThickness();
                this.smooth = this.moveShape.getSmooth();
                this.gradient = this.moveShape.getGradient();
                
                if(this.moveShape.getPattern()[0] == 1.0F & this.moveShape.getPattern()[1] == 0.0F){
                    this.pattern = "Línea continua";
                }
                
                else{
                    this.pattern = "Línea punteada";
                }
                
                this.notifyChangeParametersEvent(new LienzoEvent(this,this.borderColor, this.fillColor, this.isFilled, this.transparency,
                        this.thickness, this.smooth, this.gradient, this.pattern));
                
                break;
            }
            
        }
        
        if(this.shapeSelected == false){    //No hemos pincahdo en ninguna figura
            for(int i = 0; i < vShape.size(); i++){
                vShape.get(i).setBoundingBox(null);
                this.repaint();

            }
            this.moveShape = null;
        }
        

    }
    
    
    /**
     * Método para poder mover las figuras cuando la hemos seleccionado
     * @param moveShape figura que hemos seleccionado
     * @param movile punto móvil, el cual va variando al mover el ratón
     */
    private void moveFigure(Shape moveShape, Point movile){
        
        String type = moveShape.getClass().getName();
        
        if(type.contains("Rectangle")){
            r = (myRectangle) moveShape;
            r.setLocation(movile);
            //Lo hacemos tanto en el rectángulo como en la elipse, para que al hacer el dragged lo mueve en función del centro de la figura, y no de la esquina
            //superior derecha, lo cual es más amigable al usuario
        }
        
        else if(type.contains("Ellipse")){
            e = (myEllipse) moveShape;
            e.setLocation(movile);
        } 
        
        else{
            l = (myLine) moveShape;
            l.setLocation(p1,p2,movile);    //Método para mover los objetos myLine
        }
        
        
        //Para que se actualice y se vaya moviendo la figura también
        this.boundSelected();
        
        if(this.moveShape != null){
            this.setGradient(this.gradient);
        }

        
    }
    
    /**
     * Método para calcular la diferencia del punto inicial y final de la recta
     * @param moveShape figura seleccionada (debe ser una recta)
     * @param p punto sobre el que hemos hecho click
     */
    public void isLine(Shape moveShape, Point2D p){
        
        if (this.moveShape != null & this.shapeSelected == true & this.moveShape.getTypeOfShape() == "myLine"){
                l = (myLine)moveShape;
                p1 = l.calculateP1(p);
                p2 = l.calculateP2(p);
            }
    }
    
    /**
     * Método para generar un boundingBox de la figura
     */
    public void boundSelected(){
        if(this.edit = true){
            //Si vamos a editar, creamos el boundingbox
            float pattern[] = {2.0f, 3.0f};
            float thickness = 1.0f;
            BasicStroke basicStroke = new BasicStroke(thickness, BasicStroke.CAP_SQUARE,BasicStroke.JOIN_MITER, 1.0f, pattern, 0.0f);
            Stroke border = (Stroke) basicStroke;
            
            //Si hay figura
            if(this.moveShape != null & this.shapeSelected == true){	
                
                double space = 5;
                
                this.boundingBox = new myRectangle(this.moveShape.getBounds2D().getX()-(double)space,
                        this.moveShape.getBounds2D().getY()-(double)space,this.moveShape.getBounds2D().getWidth()+2*(double)space,
                        this.moveShape.getBounds2D().getHeight()+2*(double)space);
                
                this.boundingBox.setStroke(border);
                
                this.moveShape.setBoundingBox(this.boundingBox);
            }
            else{
                this.boundingBox = null;
                this.moveShape.setBoundingBox(null);
            }
           
        }
        
        for(int i = vShape.size()-1; i >=0; i--){
            if(vShape.get(i) != this.moveShape){
                vShape.get(i).setBoundingBox(null);
            }
            
        }
        
       
    }

         
    /**
     * Método para limpiar el vector de formas (por ejemplo, para cuando las 
     * volcamos en una imagen)
     */
    public void cleanShapeList(){
        this.vShape.clear();
    }

    
/**
 * Método para crear figuras y añadirlas al vector de figuras
 * @param origin punto origen de la figura
 */   
      
    private void createFigure(Point origin){
        
        switch(currentFigure){
               
            case LINE:
               l = new myLine(origin,origin);
               vShape.add(l);
               moveShape = l;
               
               break;
               
            case OVAL:
                e = new myEllipse(origin);
                vShape.add(e);
                moveShape = e;
                break;
              
            case RECTANGLE:
                r = new myRectangle(origin);
                vShape.add(r);
                moveShape = r;
                break;
              
            case NULL:

                
       }
        
       setParameters(moveShape);
       moveShape = null;
    }
    
    /**
     * Método para poder añadir manejadores a la lista
     * @param listener manejador a añadir
     */
    public void addLienzoListener(LienzoListener listener) {
        if (listener != null) {
            lienzoEventListeners.add(listener);
        }
    }
    
    /**
     * Método para avisar a los manejadores que ha ocurrido el evento "setCoordinates"
     * @param evt evento ocurrido
     */
    private void notifysetCoordinatesEvent(LienzoEvent evt) {
        if (!lienzoEventListeners.isEmpty()) {
            for (LienzoListener listener : lienzoEventListeners) {
                listener.setCoordinates(evt);
            }
        }
    }
    
    /**
     * Método para avisar a los manejadores que ha ocurrido el evento "Outside"
     * @param evt evento ocurrido
     */
    private void notifyOutsideEvent(LienzoEvent evt) {
        if (!lienzoEventListeners.isEmpty()) {
            for (LienzoListener listener : lienzoEventListeners) {
                listener.isOutside(evt);
            }
        }
    }
    
    /**
     * Método para avisar a los manejadores que ha ocurrido el evento "ChangeParameters"
     * @param evt evento ocurrido
     */
    private void notifyChangeParametersEvent(LienzoEvent evt) {
        if (!lienzoEventListeners.isEmpty()) {
            for (LienzoListener listener : lienzoEventListeners) {
                listener.changeParameters(evt);
            }
        }
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel form;
    // End of variables declaration//GEN-END:variables
}
